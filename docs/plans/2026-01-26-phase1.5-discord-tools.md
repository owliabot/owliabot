# Phase 1.5: Discord + Tool Execution Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Complete the MVP by adding Discord channel support and tool execution loop with basic tools.

**Architecture:** Discord plugin mirrors Telegram pattern using discord.js. Tool executor creates an agentic loop - LLM can call tools, we execute them, feed results back until LLM produces final response. Basic tools (echo, help, clear) demonstrate the pattern.

**Tech Stack:** discord.js (already in package.json), existing tool interfaces

---

## Prerequisites

- MVP Phase 1 complete (Telegram working)
- Discord bot token (from Discord Developer Portal)
- discord.js already installed

---

## Task 1: Discord Channel Plugin

**Files:**
- Create: `src/channels/discord/index.ts`

**Step 1: Create Discord plugin**

```typescript
// src/channels/discord/index.ts
import { Client, GatewayIntentBits, Events } from "discord.js";
import { createLogger } from "../../utils/logger.js";
import type {
  ChannelPlugin,
  MessageHandler,
  MsgContext,
  OutboundMessage,
  ChannelCapabilities,
} from "../interface.js";

const log = createLogger("discord");

export interface DiscordConfig {
  token: string;
  allowList?: string[];
}

export function createDiscordPlugin(config: DiscordConfig): ChannelPlugin {
  const client = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.DirectMessages,
      GatewayIntentBits.MessageContent,
    ],
  });

  let messageHandler: MessageHandler | null = null;

  const capabilities: ChannelCapabilities = {
    reactions: true,
    threads: true,
    buttons: true,
    markdown: true,
    maxMessageLength: 2000,
  };

  return {
    id: "discord",
    capabilities,

    async start() {
      log.info("Starting Discord bot...");

      client.on(Events.MessageCreate, async (message) => {
        // Ignore bot messages
        if (message.author.bot) return;
        if (!messageHandler) return;

        // MVP: only handle DMs
        const isDM = !message.guild;
        if (!isDM) {
          log.debug("Ignoring guild message");
          return;
        }

        // Check allowlist
        if (config.allowList && config.allowList.length > 0) {
          if (!config.allowList.includes(message.author.id)) {
            log.warn(`User ${message.author.id} not in allowlist`);
            return;
          }
        }

        const msgCtx: MsgContext = {
          from: message.author.id,
          senderName: message.author.displayName ?? message.author.username,
          senderUsername: message.author.username,
          body: message.content,
          messageId: message.id,
          replyToId: message.reference?.messageId,
          channel: "discord",
          chatType: "direct",
          groupId: undefined,
          timestamp: message.createdTimestamp,
        };

        try {
          await messageHandler(msgCtx);
        } catch (err) {
          log.error("Error handling message", err);
        }
      });

      await client.login(config.token);
      log.info("Discord bot started");
    },

    async stop() {
      log.info("Stopping Discord bot...");
      client.destroy();
      log.info("Discord bot stopped");
    },

    onMessage(handler: MessageHandler) {
      messageHandler = handler;
    },

    async send(target: string, message: OutboundMessage) {
      const user = await client.users.fetch(target);
      const dmChannel = await user.createDM();
      await dmChannel.send(message.text);
    },
  };
}
```

**Step 2: Verify it compiles**

Run: `npm run typecheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/channels/discord/
git commit -m "feat(discord): add Discord channel plugin"
```

---

## Task 2: Register Discord in Gateway

**Files:**
- Modify: `src/gateway/server.ts`

**Step 1: Add Discord import and registration**

Add import at top:
```typescript
import { createDiscordPlugin } from "../channels/discord/index.js";
```

Add after Telegram registration (around line 42):
```typescript
  // Register Discord if configured
  if (config.discord) {
    const discord = createDiscordPlugin({
      token: config.discord.token,
      allowList: config.discord.allowList,
    });

    discord.onMessage(async (ctx) => {
      await handleMessage(ctx, config, workspace, sessions, channels);
    });

    channels.register(discord);
  }
```

**Step 2: Verify it compiles**

Run: `npm run typecheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/gateway/server.ts
git commit -m "feat(gateway): register Discord channel"
```

---

## Task 3: Tool Registry

**Files:**
- Create: `src/agent/tools/registry.ts`

**Step 1: Create tool registry**

```typescript
// src/agent/tools/registry.ts
/**
 * Tool registry for managing available tools
 * @see design.md Section 5.2
 */

import { createLogger } from "../../utils/logger.js";
import type { ToolDefinition } from "./interface.js";

const log = createLogger("tools");

export class ToolRegistry {
  private tools = new Map<string, ToolDefinition>();

  register(tool: ToolDefinition): void {
    if (this.tools.has(tool.name)) {
      log.warn(`Tool ${tool.name} already registered, overwriting`);
    }
    this.tools.set(tool.name, tool);
    log.debug(`Registered tool: ${tool.name}`);
  }

  get(name: string): ToolDefinition | undefined {
    return this.tools.get(name);
  }

  getAll(): ToolDefinition[] {
    return Array.from(this.tools.values());
  }

  getReadOnly(): ToolDefinition[] {
    return this.getAll().filter((t) => t.security.level === "read");
  }

  toAnthropicFormat(): AnthropicTool[] {
    return this.getAll().map((tool) => ({
      name: tool.name,
      description: tool.description,
      input_schema: tool.parameters,
    }));
  }
}

export interface AnthropicTool {
  name: string;
  description: string;
  input_schema: {
    type: "object";
    properties: Record<string, unknown>;
    required?: string[];
  };
}
```

**Step 2: Verify it compiles**

Run: `npm run typecheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/agent/tools/registry.ts
git commit -m "feat(tools): add tool registry"
```

---

## Task 4: Tool Executor

**Files:**
- Create: `src/agent/tools/executor.ts`

**Step 1: Create tool executor**

```typescript
// src/agent/tools/executor.ts
/**
 * Tool executor - runs tools and returns results
 * @see design.md Section 5.2
 */

import { createLogger } from "../../utils/logger.js";
import type {
  ToolDefinition,
  ToolCall,
  ToolResult,
  ToolContext,
} from "./interface.js";
import type { ToolRegistry } from "./registry.js";

const log = createLogger("executor");

export interface ExecutorOptions {
  registry: ToolRegistry;
  context: Omit<ToolContext, "requestConfirmation">;
}

export async function executeToolCall(
  call: ToolCall,
  options: ExecutorOptions
): Promise<ToolResult> {
  const { registry, context } = options;

  const tool = registry.get(call.name);
  if (!tool) {
    log.error(`Unknown tool: ${call.name}`);
    return {
      success: false,
      error: `Unknown tool: ${call.name}`,
    };
  }

  // MVP: Only allow read-level tools without confirmation
  if (tool.security.level !== "read") {
    log.warn(`Tool ${call.name} requires ${tool.security.level} level, skipping`);
    return {
      success: false,
      error: `Tool ${call.name} requires confirmation (not implemented in MVP)`,
    };
  }

  try {
    log.info(`Executing tool: ${call.name}`);
    const result = await tool.execute(call.arguments, {
      ...context,
      requestConfirmation: async () => false, // MVP: no confirmation flow
    });
    log.info(`Tool ${call.name} completed: ${result.success}`);
    return result;
  } catch (err) {
    log.error(`Tool ${call.name} failed`, err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

export async function executeToolCalls(
  calls: ToolCall[],
  options: ExecutorOptions
): Promise<Map<string, ToolResult>> {
  const results = new Map<string, ToolResult>();

  for (const call of calls) {
    const result = await executeToolCall(call, options);
    results.set(call.id, result);
  }

  return results;
}
```

**Step 2: Verify it compiles**

Run: `npm run typecheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/agent/tools/executor.ts
git commit -m "feat(tools): add tool executor"
```

---

## Task 5: Basic Tools (echo, help, clear)

**Files:**
- Create: `src/agent/tools/builtin/echo.ts`
- Create: `src/agent/tools/builtin/help.ts`
- Create: `src/agent/tools/builtin/clear-session.ts`
- Create: `src/agent/tools/builtin/index.ts`

**Step 1: Create echo tool**

```typescript
// src/agent/tools/builtin/echo.ts
import type { ToolDefinition } from "../interface.js";

export const echoTool: ToolDefinition = {
  name: "echo",
  description: "Echo back the provided message. Useful for testing.",
  parameters: {
    type: "object",
    properties: {
      message: {
        type: "string",
        description: "The message to echo back",
      },
    },
    required: ["message"],
  },
  security: {
    level: "read",
  },
  async execute(params) {
    const { message } = params as { message: string };
    return {
      success: true,
      data: { echoed: message },
    };
  },
};
```

**Step 2: Create help tool**

```typescript
// src/agent/tools/builtin/help.ts
import type { ToolDefinition } from "../interface.js";
import type { ToolRegistry } from "../registry.js";

export function createHelpTool(registry: ToolRegistry): ToolDefinition {
  return {
    name: "help",
    description: "List all available tools and their descriptions.",
    parameters: {
      type: "object",
      properties: {},
    },
    security: {
      level: "read",
    },
    async execute() {
      const tools = registry.getAll();
      const toolList = tools.map((t) => ({
        name: t.name,
        description: t.description,
        level: t.security.level,
      }));

      return {
        success: true,
        data: { tools: toolList },
      };
    },
  };
}
```

**Step 3: Create clear-session tool**

```typescript
// src/agent/tools/builtin/clear-session.ts
import type { ToolDefinition } from "../interface.js";
import type { SessionManager } from "../../session.js";

export function createClearSessionTool(
  sessions: SessionManager
): ToolDefinition {
  return {
    name: "clear_session",
    description: "Clear the current conversation history. Use when the user wants to start fresh.",
    parameters: {
      type: "object",
      properties: {},
    },
    security: {
      level: "read", // Read because it only affects current session
    },
    async execute(_params, ctx) {
      await sessions.clear(ctx.sessionKey as `${"telegram" | "discord"}:${string}`);
      return {
        success: true,
        data: { message: "Session cleared" },
      };
    },
  };
}
```

**Step 4: Create index file**

```typescript
// src/agent/tools/builtin/index.ts
export { echoTool } from "./echo.js";
export { createHelpTool } from "./help.js";
export { createClearSessionTool } from "./clear-session.js";
```

**Step 5: Verify it compiles**

Run: `npm run typecheck`
Expected: No errors

**Step 6: Commit**

```bash
git add src/agent/tools/builtin/
git commit -m "feat(tools): add builtin tools (echo, help, clear_session)"
```

---

## Task 6: Update Anthropic Provider for Tool Use

**Files:**
- Modify: `src/agent/providers/anthropic.ts`

**Step 1: Update callAnthropic to support tools**

Replace the function with:

```typescript
// src/agent/providers/anthropic.ts
import { createLogger } from "../../utils/logger.js";
import type { Message } from "../session.js";
import type { LLMResponse, CallOptions } from "../runner.js";
import type { ToolCall } from "../tools/interface.js";
import { HTTPError } from "../runner.js";

const log = createLogger("anthropic");

const ANTHROPIC_API_URL = "https://api.anthropic.com/v1/messages";

export interface AnthropicConfig {
  apiKey: string;
  model: string;
}

export async function callAnthropic(
  config: AnthropicConfig,
  messages: Message[],
  options?: CallOptions
): Promise<LLMResponse> {
  log.debug(`Calling Anthropic ${config.model}`);

  // Convert messages to Anthropic format
  const anthropicMessages = messages
    .filter((m) => m.role !== "system")
    .map((m) => ({
      role: m.role as "user" | "assistant",
      content: m.content,
    }));

  const systemMessage = messages.find((m) => m.role === "system");

  const body: Record<string, unknown> = {
    model: config.model,
    max_tokens: options?.maxTokens ?? 4096,
    system: systemMessage?.content,
    messages: anthropicMessages,
  };

  // Add tools if provided
  if (options?.tools && options.tools.length > 0) {
    body.tools = options.tools.map((t) => ({
      name: t.name,
      description: t.description,
      input_schema: t.parameters,
    }));
  }

  const response = await fetch(ANTHROPIC_API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": config.apiKey,
      "anthropic-version": "2023-06-01",
    },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const text = await response.text();
    log.error(`Anthropic error: ${response.status} ${text}`);
    throw new HTTPError(response.status, text);
  }

  const data = (await response.json()) as AnthropicResponse;

  // Extract text content
  const content = data.content
    .filter((c): c is { type: "text"; text: string } => c.type === "text")
    .map((c) => c.text)
    .join("");

  // Extract tool calls
  const toolCalls: ToolCall[] = data.content
    .filter(
      (c): c is { type: "tool_use"; id: string; name: string; input: unknown } =>
        c.type === "tool_use"
    )
    .map((c) => ({
      id: c.id,
      name: c.name,
      arguments: c.input,
    }));

  return {
    content,
    toolCalls: toolCalls.length > 0 ? toolCalls : undefined,
    usage: {
      promptTokens: data.usage.input_tokens,
      completionTokens: data.usage.output_tokens,
    },
    provider: "anthropic",
  };
}

interface AnthropicResponse {
  content: Array<
    | { type: "text"; text: string }
    | { type: "tool_use"; id: string; name: string; input: unknown }
  >;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
  stop_reason: string;
}
```

**Step 2: Verify it compiles**

Run: `npm run typecheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/agent/providers/anthropic.ts
git commit -m "feat(anthropic): add tool use support"
```

---

## Task 7: Agentic Loop in Gateway

**Files:**
- Modify: `src/gateway/server.ts`

**Step 1: Add imports**

Add at top:
```typescript
import { ToolRegistry } from "../agent/tools/registry.js";
import { executeToolCalls } from "../agent/tools/executor.js";
import { echoTool, createHelpTool, createClearSessionTool } from "../agent/tools/builtin/index.js";
import type { ToolCall, ToolResult } from "../agent/tools/interface.js";
```

**Step 2: Create tool registry in startGateway**

After `const sessions = createSessionManager(sessionsDir);` add:
```typescript
  // Create tool registry and register builtin tools
  const tools = new ToolRegistry();
  tools.register(echoTool);
  tools.register(createHelpTool(tools));
  tools.register(createClearSessionTool(sessions));
```

**Step 3: Update handleMessage call to include tools**

Update the onMessage handlers to pass tools:
```typescript
    telegram.onMessage(async (ctx) => {
      await handleMessage(ctx, config, workspace, sessions, channels, tools);
    });
```

And same for Discord.

**Step 4: Update handleMessage function signature and add agentic loop**

Replace the entire `handleMessage` function with:

```typescript
async function handleMessage(
  ctx: MsgContext,
  config: Config,
  workspace: WorkspaceFiles,
  sessions: ReturnType<typeof createSessionManager>,
  channels: ChannelRegistry,
  tools: ToolRegistry
): Promise<void> {
  const sessionKey: SessionKey = `${ctx.channel}:${ctx.from}`;

  log.info(`Message from ${sessionKey}: ${ctx.body.slice(0, 50)}...`);

  // Append user message to session
  const userMessage: Message = {
    role: "user",
    content: ctx.body,
    timestamp: ctx.timestamp,
  };
  await sessions.append(sessionKey, userMessage);

  // Get conversation history
  const history = await sessions.getHistory(sessionKey);

  // Build system prompt
  const systemPrompt = buildSystemPrompt({
    workspace,
    channel: ctx.channel,
    timezone: "UTC+8", // TODO: from config
    model: config.providers[0].model,
  });

  // Agentic loop
  const MAX_ITERATIONS = 5;
  let iteration = 0;
  let finalContent = "";

  const conversationMessages: Message[] = [
    { role: "system", content: systemPrompt, timestamp: Date.now() },
    ...history,
  ];

  while (iteration < MAX_ITERATIONS) {
    iteration++;
    log.debug(`Agentic loop iteration ${iteration}`);

    // Call LLM with tools
    const providers: LLMProvider[] = config.providers;
    const response = await callWithFailover(providers, conversationMessages, {
      tools: tools.getAll(),
    });

    // If no tool calls, we're done
    if (!response.toolCalls || response.toolCalls.length === 0) {
      finalContent = response.content;
      break;
    }

    log.info(`LLM requested ${response.toolCalls.length} tool calls`);

    // Execute tool calls
    const toolResults = await executeToolCalls(response.toolCalls, {
      registry: tools,
      context: {
        sessionKey,
        agentId: "owliabot",
        signer: null as any, // MVP: no signer
        config: {},
      },
    });

    // Add assistant message with tool calls to conversation
    conversationMessages.push({
      role: "assistant",
      content: response.content || "",
      timestamp: Date.now(),
      toolCalls: response.toolCalls,
    });

    // Add tool results as user message (Anthropic format)
    const toolResultContent = formatToolResults(response.toolCalls, toolResults);
    conversationMessages.push({
      role: "user",
      content: toolResultContent,
      timestamp: Date.now(),
    });
  }

  if (!finalContent && iteration >= MAX_ITERATIONS) {
    finalContent = "I apologize, but I couldn't complete your request. Please try again.";
  }

  log.info(`Final response: ${finalContent.slice(0, 50)}...`);

  // Append assistant response to session
  const assistantMessage: Message = {
    role: "assistant",
    content: finalContent,
    timestamp: Date.now(),
  };
  await sessions.append(sessionKey, assistantMessage);

  // Send response
  const channel = channels.get(ctx.channel);
  if (channel) {
    await channel.send(ctx.from, {
      text: finalContent,
      replyToId: ctx.messageId,
    });
  }
}

function formatToolResults(
  calls: ToolCall[],
  results: Map<string, ToolResult>
): string {
  const formatted = calls.map((call) => {
    const result = results.get(call.id);
    if (!result) {
      return `Tool ${call.name} (${call.id}): No result`;
    }
    if (result.success) {
      return `Tool ${call.name} (${call.id}) succeeded:\n${JSON.stringify(result.data, null, 2)}`;
    }
    return `Tool ${call.name} (${call.id}) failed: ${result.error}`;
  });

  return `Tool results:\n${formatted.join("\n\n")}`;
}
```

**Step 5: Verify it compiles**

Run: `npm run typecheck`
Expected: No errors

**Step 6: Commit**

```bash
git add src/gateway/server.ts
git commit -m "feat(gateway): add agentic loop with tool execution"
```

---

## Task 8: Update Config Example

**Files:**
- Modify: `config.example.yaml`

**Step 1: Add Discord section**

Add after Telegram section:
```yaml
# Discord (optional)
discord:
  token: ${DISCORD_BOT_TOKEN}
  # allowList:
  #   - "123456789012345678"
```

**Step 2: Commit**

```bash
git add config.example.yaml
git commit -m "docs: add Discord config example"
```

---

## Summary

After completing all tasks, you will have:

1. ✅ Discord channel plugin (mirrors Telegram pattern)
2. ✅ Tool registry for managing tools
3. ✅ Tool executor for running tools
4. ✅ Basic builtin tools (echo, help, clear_session)
5. ✅ Anthropic provider with tool use support
6. ✅ Agentic loop in gateway (LLM → tools → LLM → response)
7. ✅ Updated config for Discord

**MVP completion: ~95%** (missing only Heartbeat, which is Phase 2)

**Test by:**
1. Start bot with Discord token
2. Send "what tools do you have?" → LLM should call help tool
3. Send "echo hello world" → LLM should call echo tool
4. Send "clear my history" → LLM should call clear_session tool
