import { mkdir, writeFile } from "node:fs/promises";
import { isAbsolute, join, resolve } from "node:path";
import { stringify } from "yaml";
import { createLogger } from "../../utils/logger.js";
import type { PersonaFrontmatter } from "../types.js";
import type { PersonaBootstrapQuestion } from "./questions.js";
import { DEFAULT_BOOTSTRAP_QUESTIONS } from "./questions.js";

const log = createLogger("persona.bootstrap.generator");

export type PersonaOverlayStatus = "draft" | "confirmed";

export interface PersonaOverlayGenerationOptions {
  agentId: string;
  answers: Record<string, unknown>;
  rootDir?: string;
  personaDir?: string;
  questions?: PersonaBootstrapQuestion[];
  status?: PersonaOverlayStatus;
  now?: Date;
  body?: string;
}

export interface PersonaOverlayGenerationResult {
  path: string;
  frontmatter: PersonaFrontmatter;
  rawFrontmatter: Record<string, unknown>;
  content: string;
}

export async function generatePersonaOverlay(
  options: PersonaOverlayGenerationOptions
): Promise<PersonaOverlayGenerationResult> {
  assertValidAgentId(options.agentId);
  const frontmatter = buildPersonaFrontmatter(options);
  const now = options.now ?? new Date();
  const status = options.status ?? "draft";
  const rawFrontmatter = buildRawFrontmatter(frontmatter, {
    status,
    createdAt: now,
    updatedAt: now,
  });

  const yaml = stringify(rawFrontmatter, { indent: 2, lineWidth: 0 }).trimEnd();
  const body = (options.body ?? "Agent overlay generated by bootstrap.").trim();
  const content = `---\n${yaml}\n---\n\n${body}\n`;

  const rootDir = options.rootDir ?? process.cwd();
  const personaDir = options.personaDir ?? "persona";
  const personaRoot = resolve(rootDir, personaDir);
  const agentDir = join(personaRoot, "agents", options.agentId);
  await mkdir(agentDir, { recursive: true });

  const path = join(agentDir, "overlay.md");
  await writeFile(path, content, "utf-8");

  log.info(`Generated persona overlay at ${path}`);

  return { path, frontmatter, rawFrontmatter, content };
}

export function assertValidAgentId(agentId: string): void {
  const trimmed = agentId.trim();
  if (!trimmed) {
    throw new Error("Invalid agent id: empty value");
  }
  if (isAbsolute(agentId)) {
    throw new Error(`Invalid agent id: absolute path not allowed (${agentId})`);
  }
  if (agentId.includes("..")) {
    throw new Error(`Invalid agent id: path traversal not allowed (${agentId})`);
  }
  if (/[\\/]/.test(agentId)) {
    throw new Error(`Invalid agent id: path separators not allowed (${agentId})`);
  }
}

export interface PersonaFrontmatterBuildOptions
  extends Pick<PersonaOverlayGenerationOptions, "agentId" | "answers" | "questions"> {
  schemaVersion?: string;
}

export function buildPersonaFrontmatter(
  options: PersonaFrontmatterBuildOptions
): PersonaFrontmatter {
  const questions = options.questions ?? DEFAULT_BOOTSTRAP_QUESTIONS;
  const frontmatter: PersonaFrontmatter = {
    schemaVersion: options.schemaVersion ?? "1.0",
    id: options.agentId,
  };

  for (const question of questions) {
    const rawValue = options.answers[question.id];
    const normalized = normalizeAnswer(rawValue, question.answerType);
    if (normalized !== undefined) {
      frontmatter[question.field] = normalized as never;
    }
  }

  return frontmatter;
}

interface RawFrontmatterExtras {
  status: PersonaOverlayStatus;
  createdAt: Date;
  updatedAt: Date;
}

function buildRawFrontmatter(
  frontmatter: PersonaFrontmatter,
  extras: RawFrontmatterExtras
): Record<string, unknown> {
  const raw: Record<string, unknown> = {
    schema_version: frontmatter.schemaVersion,
    id: frontmatter.id,
    name: frontmatter.name,
    role: frontmatter.role,
    mission: frontmatter.mission,
    tone: frontmatter.tone,
    do: frontmatter.do,
    dont: frontmatter.dont,
    boundaries: frontmatter.boundaries,
    tools: frontmatter.tools,
    memory_policy: frontmatter.memoryPolicy,
    notes: frontmatter.notes,
    status: extras.status,
    created_at: extras.createdAt.toISOString(),
    updated_at: extras.updatedAt.toISOString(),
  };

  return removeUndefined(raw);
}

function normalizeAnswer(
  value: unknown,
  answerType: "string" | "string[]"
): string | string[] | undefined {
  if (value === undefined || value === null) {
    return undefined;
  }

  if (answerType === "string") {
    const normalized = normalizeString(value);
    return normalized;
  }

  const normalized = normalizeStringArray(value);
  return normalized;
}

function normalizeString(value: unknown): string | undefined {
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  }

  if (Array.isArray(value)) {
    const combined = value
      .map((item) => (typeof item === "string" ? item.trim() : ""))
      .filter((item) => item.length > 0)
      .join(", ");
    return combined.length > 0 ? combined : undefined;
  }

  return undefined;
}

function normalizeStringArray(value: unknown): string[] | undefined {
  if (Array.isArray(value)) {
    const items = value
      .map((item) => (typeof item === "string" ? item.trim() : ""))
      .filter((item) => item.length > 0);
    return items.length > 0 ? items : undefined;
  }

  if (typeof value === "string") {
    const trimmed = value.trim();
    if (trimmed.length === 0) {
      return undefined;
    }
    const items = trimmed
      .split(/[\n,;]/)
      .map((item) => item.trim())
      .filter((item) => item.length > 0);
    return items.length > 0 ? items : undefined;
  }

  return undefined;
}

function removeUndefined(input: Record<string, unknown>): Record<string, unknown> {
  const output: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(input)) {
    if (value !== undefined) {
      output[key] = value;
    }
  }
  return output;
}
