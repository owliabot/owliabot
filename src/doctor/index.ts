import fs from "node:fs";
import path from "node:path";
import { parse, stringify } from "yaml";
import { ZodError } from "zod";

import { configSchema } from "../config/schema.js";
import { expandEnvVarsDeep } from "../config/expand-env.js";
import type { SecretsConfig } from "../onboarding/secrets.js";
import { loadSecrets, saveSecrets } from "../onboarding/secrets.js";

export type DoctorIssueSeverity = "error" | "warn";
export type DoctorIssueSource = "config" | "secrets" | "env";

export interface DoctorIssue {
  id: string;
  severity: DoctorIssueSeverity;
  message: string;
  source?: DoctorIssueSource;
}

export interface DoctorReport {
  ok: boolean;
  configPath: string;
  issues: DoctorIssue[];
}

export interface DiagnoseDoctorOptions {
  configPath: string;
  env?: Record<string, string | undefined>;
}

function formatTimestampUtcCompact(now: Date): string {
  // 2026-02-10T00:00:00.000Z -> 20260210T000000Z
  return now
    .toISOString()
    .replace(/[-:]/g, "")
    .replace(/\.\d{3}Z$/, "Z");
}

async function backupFileIfExists(filePath: string, now: Date): Promise<string | null> {
  try {
    await fs.promises.stat(filePath);
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === "ENOENT") return null;
    throw err;
  }

  const backupPath = `${filePath}.bak.${formatTimestampUtcCompact(now)}`;
  await fs.promises.copyFile(filePath, backupPath);
  return backupPath;
}

async function writeAtomic(filePath: string, content: string): Promise<void> {
  const tmp = `${filePath}.${process.pid}.${Math.random().toString(16).slice(2)}.tmp`;
  await fs.promises.writeFile(tmp, content, "utf-8");
  await fs.promises.rename(tmp, filePath);
  // Best-effort permissions hardening (config may contain sensitive values in some setups).
  try {
    await fs.promises.chmod(filePath, 0o600);
  } catch {
    // ignore
  }
}

function formatZodError(error: ZodError): string {
  const lines = error.errors.map((issue) => {
    const p = issue.path.length > 0 ? issue.path.join(".") : "(root)";
    return `- ${p}: ${issue.message}`;
  });
  return `Config validation failed:\n${lines.join("\n")}`;
}

function looksLikeTelegramToken(token: string): boolean {
  return /^\d+:[A-Za-z0-9_-]{20,}$/.test(token.trim());
}

function looksLikeDiscordToken(token: string): boolean {
  // Best-effort: bot tokens are typically 3 base64url-ish segments separated by dots.
  // Keep this loose to avoid false negatives when Discord changes formats.
  return /^[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{6,}\.[A-Za-z0-9_-]{20,}$/.test(
    token.trim(),
  );
}

function looksLikeOpenAiApiKey(key: string): boolean {
  const k = key.trim();
  // Best-effort: OpenAI keys typically start with "sk-" (including "sk-proj-...").
  // Avoid accepting Anthropic keys (sk-ant-...).
  if (!k.startsWith("sk-")) return false;
  if (k.startsWith("sk-ant-")) return false;
  return /^sk-[A-Za-z0-9][A-Za-z0-9_-]{10,}$/.test(k);
}

function looksLikeAnthropicSetupToken(token: string): boolean {
  const t = token.trim();
  return /^sk-ant-oat01-[A-Za-z0-9_-]{10,}$/.test(t);
}

function looksLikeAnthropicApiKey(key: string): boolean {
  const k = key.trim();
  // Best-effort: allow any sk-ant-* key (Anthropic has multiple prefixes in the wild).
  // setup-token is handled separately.
  if (!k.startsWith("sk-ant-")) return false;
  return /^sk-ant-[A-Za-z0-9_-]{10,}$/.test(k);
}

function getMinimalConfigTemplate(): string {
  return [
    "# OwliaBot minimal config (generated by `owliabot doctor`)",
    "# Tokens and API keys should live in secrets.yaml next to this file.",
    "",
    "providers:",
    "  - id: anthropic",
    "    model: claude-sonnet-4-5",
    "    apiKey: secrets",
    "    priority: 1",
    "",
    "telegram: {}",
    "discord: {}",
    "",
    "workspace: ./workspace",
    "timezone: UTC",
    "",
  ].join("\n");
}

async function loadYamlFileIfExists(
  filePath: string,
): Promise<{ ok: true; value: any } | { ok: false; error: Error } | null> {
  try {
    const txt = await fs.promises.readFile(filePath, "utf-8");
    try {
      return { ok: true, value: parse(txt) as any };
    } catch (err) {
      return { ok: false, error: err as Error };
    }
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === "ENOENT") return null;
    throw err;
  }
}

export async function resetConfigFile(opts: {
  configPath: string;
  backup?: boolean;
  now?: Date;
}): Promise<{ backupPath: string | null }> {
  const now = opts.now ?? new Date();
  const configPath = path.resolve(opts.configPath);

  const backupPath = opts.backup ? await backupFileIfExists(configPath, now) : null;

  await fs.promises.mkdir(path.dirname(configPath), { recursive: true });
  await writeAtomic(configPath, getMinimalConfigTemplate());

  return { backupPath };
}

export async function diagnoseDoctor(opts: DiagnoseDoctorOptions): Promise<DoctorReport> {
  const env = opts.env ?? process.env;
  const configPath = path.resolve(opts.configPath);
  const issues: DoctorIssue[] = [];

  const configYaml = await loadYamlFileIfExists(configPath);
  if (configYaml == null) {
    issues.push({
      id: "config.missing",
      severity: "error",
      message: `Config file not found: ${configPath}`,
      source: "config",
    });
    return { ok: false, configPath, issues };
  }
  if (!configYaml.ok) {
    issues.push({
      id: "config.parse_error",
      severity: "error",
      message: `Failed to parse YAML config: ${configYaml.error.message}`,
      source: "config",
    });
    return { ok: false, configPath, issues };
  }

  const rawConfig = configYaml.value ?? {};

  // Load secrets.yaml next to config (optional)
  const secretsPath = path.join(path.dirname(configPath), "secrets.yaml");
  const secretsYaml = await loadYamlFileIfExists(secretsPath);
  if (secretsYaml && !secretsYaml.ok) {
    issues.push({
      id: "secrets.parse_error",
      severity: "error",
      message: `Failed to parse secrets.yaml: ${secretsYaml.error.message}`,
      source: "secrets",
    });
  }
  const secrets: any = secretsYaml && secretsYaml.ok ? (secretsYaml.value ?? {}) : {};

  // Validate config against schema (after env expansion)
  try {
    const expanded = expandEnvVarsDeep(rawConfig, env);
    configSchema.parse(expanded);
  } catch (err) {
    if (err instanceof ZodError) {
      issues.push({
        id: "config.validation_error",
        severity: "error",
        message: formatZodError(err),
        source: "config",
      });
    } else {
      issues.push({
        id: "config.validation_error",
        severity: "error",
        message: `Config validation failed: ${(err as Error).message}`,
        source: "config",
      });
    }
  }

  // Credential checks (best-effort)
  const providers =
    rawConfig && typeof rawConfig === "object" && Array.isArray((rawConfig as any).providers)
      ? ((rawConfig as any).providers as any[])
      : [];

  const telegramConfigured =
    rawConfig && typeof rawConfig === "object" && (rawConfig as any).telegram != null;
  if (telegramConfigured) {
    const tokenFromConfig =
      typeof (rawConfig as any).telegram?.token === "string"
        ? ((rawConfig as any).telegram.token as string)
        : null;
    const tokenFromSecrets =
      typeof secrets?.telegram?.token === "string" ? (secrets.telegram.token as string) : null;
    const tokenFromEnv = (env.TELEGRAM_BOT_TOKEN ?? "").trim() || null;

    const token = (tokenFromConfig ?? tokenFromSecrets ?? tokenFromEnv ?? "").trim();
    if (token) {
      const source: DoctorIssueSource =
        tokenFromConfig != null ? "config" : tokenFromSecrets != null ? "secrets" : "env";
      if (tokenFromConfig != null) {
        issues.push({
          id: "security.telegram.token_in_config",
          severity: "warn",
          message: "Telegram token is stored in app.yaml; consider moving it to secrets.yaml.",
          source: "config",
        });
      }
      if (!looksLikeTelegramToken(token)) {
        issues.push({
          id: "credential.telegram.token.invalid_format",
          severity: "error",
          message: "Telegram bot token format looks wrong (expected digits:letters).",
          source,
        });
      }
    }
  }

  const discordConfigured =
    rawConfig && typeof rawConfig === "object" && (rawConfig as any).discord != null;
  if (discordConfigured) {
    const tokenFromConfig =
      typeof (rawConfig as any).discord?.token === "string"
        ? ((rawConfig as any).discord.token as string)
        : null;
    const tokenFromSecrets =
      typeof secrets?.discord?.token === "string" ? (secrets.discord.token as string) : null;
    const tokenFromEnv = (env.DISCORD_BOT_TOKEN ?? "").trim() || null;

    const token = (tokenFromConfig ?? tokenFromSecrets ?? tokenFromEnv ?? "").trim();
    if (token) {
      const source: DoctorIssueSource =
        tokenFromConfig != null ? "config" : tokenFromSecrets != null ? "secrets" : "env";
      if (tokenFromConfig != null) {
        issues.push({
          id: "security.discord.token_in_config",
          severity: "warn",
          message: "Discord token is stored in app.yaml; consider moving it to secrets.yaml.",
          source: "config",
        });
      }
      if (!looksLikeDiscordToken(token)) {
        issues.push({
          id: "credential.discord.token.invalid_format",
          severity: "error",
          message: "Discord bot token format looks wrong (expected three dot-separated parts).",
          source,
        });
      }
    }
  }

  // Provider API keys (OpenAI / Anthropic)
  for (const provider of providers) {
    const id = typeof provider?.id === "string" ? (provider.id as string) : "";
    const apiKeyField = typeof provider?.apiKey === "string" ? (provider.apiKey as string).trim() : "";

    if (id === "openai") {
      let key: string | null = null;
      let source: DoctorIssueSource = "config";

      if (apiKeyField === "secrets") {
        const fromSecrets =
          typeof secrets?.openai?.apiKey === "string" ? (secrets.openai.apiKey as string) : null;
        const fromEnv = (env.OPENAI_API_KEY ?? "").trim() || null;
        if (fromSecrets) {
          key = fromSecrets;
          source = "secrets";
        } else if (fromEnv) {
          key = fromEnv;
          source = "env";
        }
      } else if (apiKeyField === "env") {
        const fromEnv = (env.OPENAI_API_KEY ?? "").trim() || null;
        if (fromEnv) {
          key = fromEnv;
          source = "env";
        }
      } else if (apiKeyField && apiKeyField !== "oauth") {
        key = apiKeyField;
        source = "config";
      }

      if (key && !looksLikeOpenAiApiKey(key)) {
        issues.push({
          id: "credential.openai.apiKey.invalid_format",
          severity: "error",
          message: "OpenAI API key format looks wrong (expected sk-...).",
          source,
        });
      }
      if (source === "config" && key) {
        issues.push({
          id: "security.openai.apiKey_in_config",
          severity: "warn",
          message: "OpenAI API key is stored in app.yaml; consider switching provider.apiKey to 'secrets' and storing it in secrets.yaml.",
          source: "config",
        });
      }
    }

    if (id === "anthropic") {
      let value: string | null = null;
      let kind: "token" | "apiKey" = "apiKey";
      let source: DoctorIssueSource = "config";

      if (apiKeyField === "secrets") {
        const tokenFromSecrets =
          typeof secrets?.anthropic?.token === "string" ? (secrets.anthropic.token as string) : null;
        const apiKeyFromSecrets =
          typeof secrets?.anthropic?.apiKey === "string" ? (secrets.anthropic.apiKey as string) : null;
        const fromEnv = (env.ANTHROPIC_API_KEY ?? "").trim() || null;

        if (tokenFromSecrets) {
          value = tokenFromSecrets;
          kind = "token";
          source = "secrets";
        } else if (apiKeyFromSecrets) {
          value = apiKeyFromSecrets;
          kind = "apiKey";
          source = "secrets";
        } else if (fromEnv) {
          value = fromEnv;
          kind = looksLikeAnthropicSetupToken(fromEnv) ? "token" : "apiKey";
          source = "env";
        }
      } else if (apiKeyField === "env") {
        const fromEnv = (env.ANTHROPIC_API_KEY ?? "").trim() || null;
        if (fromEnv) {
          value = fromEnv;
          kind = looksLikeAnthropicSetupToken(fromEnv) ? "token" : "apiKey";
          source = "env";
        }
      } else if (apiKeyField && apiKeyField !== "oauth") {
        value = apiKeyField;
        kind = looksLikeAnthropicSetupToken(apiKeyField) ? "token" : "apiKey";
        source = "config";
      }

      if (value) {
        if (source === "config") {
          issues.push({
            id: "security.anthropic.key_in_config",
            severity: "warn",
            message: "Anthropic credential is stored in app.yaml; consider switching provider.apiKey to 'secrets' and storing it in secrets.yaml.",
            source: "config",
          });
        }
        if (kind === "token" && !looksLikeAnthropicSetupToken(value)) {
          issues.push({
            id: "credential.anthropic.token.invalid_format",
            severity: "error",
            message: "Anthropic setup-token format looks wrong (expected sk-ant-oat01-...).",
            source,
          });
        } else if (kind === "apiKey" && !looksLikeAnthropicApiKey(value) && !looksLikeAnthropicSetupToken(value)) {
          // Accept setup-token in env even if we guessed apiKey.
          issues.push({
            id: "credential.anthropic.apiKey.invalid_format",
            severity: "error",
            message: "Anthropic API key format looks wrong (expected sk-ant-api...).",
            source,
          });
        }
      }
    }
  }

  return { ok: issues.every((i) => i.severity !== "error"), configPath, issues };
}

async function updateConfigYaml(configPath: string, updater: (raw: any) => void): Promise<void> {
  const txt = await fs.promises.readFile(configPath, "utf-8");
  const raw = parse(txt) as any;
  updater(raw);
  const out = stringify(raw ?? {}, { indent: 2 });
  await writeAtomic(configPath, out);
}

async function updateSecretsYaml(
  appConfigPath: string,
  updater: (secrets: SecretsConfig) => void,
): Promise<void> {
  const current = (await loadSecrets(appConfigPath)) ?? {};
  updater(current);
  await saveSecrets(appConfigPath, current);
}

export async function setChannelToken(opts: {
  configPath: string;
  channel: "telegram" | "discord";
  token: string;
}): Promise<void> {
  const configPath = path.resolve(opts.configPath);

  // Prefer storing secrets in secrets.yaml, not app.yaml.
  await updateConfigYaml(configPath, (raw) => {
    raw[opts.channel] = raw[opts.channel] ?? {};
    if (raw[opts.channel] && typeof raw[opts.channel] === "object") {
      delete raw[opts.channel].token;
    }
  });

  await updateSecretsYaml(configPath, (secrets) => {
    (secrets as any)[opts.channel] = (secrets as any)[opts.channel] ?? {};
    (secrets as any)[opts.channel].token = opts.token;
  });
}

export async function deleteChannelToken(opts: {
  configPath: string;
  channel: "telegram" | "discord";
}): Promise<void> {
  const configPath = path.resolve(opts.configPath);

  // Best-effort: clear config token too.
  try {
    await updateConfigYaml(configPath, (raw) => {
      if (raw[opts.channel] && typeof raw[opts.channel] === "object") {
        delete raw[opts.channel].token;
      }
    });
  } catch {
    // ignore
  }

  await updateSecretsYaml(configPath, (secrets) => {
    if ((secrets as any)[opts.channel] && typeof (secrets as any)[opts.channel] === "object") {
      delete (secrets as any)[opts.channel].token;
      if (Object.keys((secrets as any)[opts.channel]).length === 0) {
        delete (secrets as any)[opts.channel];
      }
    }
  });
}

export async function setProviderSecret(opts: {
  configPath: string;
  provider: keyof SecretsConfig;
  field: "apiKey" | "token";
  value: string;
}): Promise<void> {
  const configPath = path.resolve(opts.configPath);
  await updateSecretsYaml(configPath, (secrets) => {
    (secrets as any)[opts.provider] = (secrets as any)[opts.provider] ?? {};
    if ((secrets as any)[opts.provider] && typeof (secrets as any)[opts.provider] !== "object") {
      (secrets as any)[opts.provider] = {};
    }
    (secrets as any)[opts.provider][opts.field] = opts.value;
  });
}

export async function deleteProviderSecret(opts: {
  configPath: string;
  provider: keyof SecretsConfig;
  field: "apiKey" | "token";
}): Promise<void> {
  const configPath = path.resolve(opts.configPath);
  await updateSecretsYaml(configPath, (secrets) => {
    if ((secrets as any)[opts.provider] && typeof (secrets as any)[opts.provider] === "object") {
      delete (secrets as any)[opts.provider][opts.field];
      if (Object.keys((secrets as any)[opts.provider]).length === 0) {
        delete (secrets as any)[opts.provider];
      }
    }
  });
}

function updateProviderInConfig(raw: any, providerId: string, updater: (p: any) => void): void {
  if (!raw || typeof raw !== "object") return;
  if (!Array.isArray(raw.providers)) return;
  const p = raw.providers.find((x: any) => x && typeof x === "object" && x.id === providerId);
  if (!p) return;
  updater(p);
}

export async function setProviderApiKeyInConfig(opts: {
  configPath: string;
  providerId: string;
  apiKey: string;
}): Promise<void> {
  const configPath = path.resolve(opts.configPath);
  await updateConfigYaml(configPath, (raw) => {
    updateProviderInConfig(raw, opts.providerId, (p) => {
      p.apiKey = opts.apiKey;
    });
  });
}

export async function setProviderApiKeyModeInConfig(opts: {
  configPath: string;
  providerId: string;
  mode: "secrets" | "env" | "oauth";
}): Promise<void> {
  const configPath = path.resolve(opts.configPath);
  await updateConfigYaml(configPath, (raw) => {
    updateProviderInConfig(raw, opts.providerId, (p) => {
      p.apiKey = opts.mode;
    });
  });
}

export async function deleteProviderApiKeyInConfig(opts: {
  configPath: string;
  providerId: string;
}): Promise<void> {
  const configPath = path.resolve(opts.configPath);
  await updateConfigYaml(configPath, (raw) => {
    updateProviderInConfig(raw, opts.providerId, (p) => {
      delete p.apiKey;
    });
  });
}
