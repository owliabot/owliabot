/**
 * Docker-specific onboarding logic
 */

import { homedir } from "node:os";
import { join } from "node:path";
import { mkdirSync, writeFileSync, readdirSync, lstatSync, chmodSync } from "node:fs";
import type { AppConfig } from "../types.js";
import type { SecretsConfig } from "../secrets.js";
import { header, info, success, COLORS } from "../shared.js";
import type { createInterface } from "node:readline";

type RL = ReturnType<typeof createInterface>;

export interface DockerPaths {
  /** Host directory where we write app.yaml + secrets.yaml */
  configDir: string;
  dockerConfigPath: string;
  shellConfigPath: string;
  outputDir: string;
}

export interface DockerComposeSetup {
  gatewayToken: string;
  gatewayPort: string;
}

/**
 * Initialize Docker paths structure.
 */
export function initDockerPaths(outputDir?: string): DockerPaths {
  // Docker mode always uses the host user's config directory.
  // This keeps volume mounts stable across machines and avoids /app/... host paths
  // that Docker Desktop (macOS) cannot mount.
  const hostConfigDirAbs = join(homedir(), ".owliabot");
  const dockerConfigPath = "~/.owliabot";
  const shellConfigPath = "~/.owliabot";
  const outDir = outputDir ?? ".";

  mkdirSync(hostConfigDirAbs, { recursive: true });

  return {
    configDir: hostConfigDirAbs,
    dockerConfigPath,
    shellConfigPath,
    outputDir: outDir,
  };
}

/**
 * Prompt for Docker Compose-specific settings.
 */
export async function promptDockerComposeSetup(
  _rl: RL,
  gatewayToken: string,
): Promise<DockerComposeSetup> {
  header("Docker");
  info("Using default Gateway port: 8787");
  return { gatewayToken, gatewayPort: "8787" };
}

/**
 * Build environment variable lines for Docker Compose.
 */
export function buildDockerEnvLines(
  config: AppConfig,
  secrets: SecretsConfig,
  tz: string,
): string[] {
  const env: string[] = [];
  env.push(`TZ=${tz}`);

  // Channel tokens: only needed if user didn't store them in secrets.yaml
  if (config.discord && !secrets.discord?.token) {
    env.push("DISCORD_BOT_TOKEN=${DISCORD_BOT_TOKEN}");
  }
  if (config.telegram && !secrets.telegram?.token) {
    env.push("TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}");
  }

  // Provider keys: only needed when provider explicitly uses env auth
  if (config.providers.some((p) => p.id === "anthropic" && p.apiKey === "env")) {
    env.push("ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}");
  }
  if (config.providers.some((p) => p.id === "openai" && p.apiKey === "env")) {
    env.push("OPENAI_API_KEY=${OPENAI_API_KEY}");
  }

  return env;
}

/**
 * Build docker-compose.yml content.
 */
export function buildDockerComposeYaml(
  dockerConfigPath: string,
  envLines: string[],
  gatewayPort: string,
  defaultImage: string,
): string {
  const envBlock = envLines.length > 0
    ? envLines.map((v) => `      - ${v}`).join("\n")
    : "      - TZ=UTC";
  // Intentionally use `~` in docker-compose.yml so the file is portable and resolves
  // to the host user's home directory.
  return `# docker-compose.yml for OwliaBot
# Generated by onboard

services:
  owliabot:
    image: \${OWLIABOT_IMAGE:-${defaultImage}}
    container_name: owliabot
    restart: unless-stopped
    ports:
      - "127.0.0.1:${gatewayPort}:8787"
    volumes:
      - ${dockerConfigPath}:/home/owliabot/.owliabot
      # Legacy compatibility: older configs may use workspace: /app/workspace
      - ${dockerConfigPath}/workspace:/app/workspace
    environment:
${envBlock}
    command: ["start", "-c", "/home/owliabot/.owliabot/app.yaml"]
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8787/health"]
      interval: 5s
      timeout: 3s
      retries: 3
      start_period: 10s
`;
}

/**
 * Apply permission widening for Docker bind mounts.
 * Best-effort: widen permissions to a+rwX for the bind-mounted tree.
 * This is only applied in docker mode.
 */
export function tryMakeTreeWritableForDocker(rootPath: string): void {
  if (process.platform === "win32") return;

  const stack: string[] = [rootPath];
  while (stack.length > 0) {
    const p = stack.pop();
    if (!p) break;

    let st: ReturnType<typeof lstatSync>;
    try {
      st = lstatSync(p);
    } catch {
      continue;
    }

    if (st.isSymbolicLink()) continue;

    if (st.isDirectory()) {
      try { chmodSync(p, 0o777); } catch { /* best-effort */ }
      let entries;
      try { entries = readdirSync(p, { withFileTypes: true }); } catch { continue; }
      for (const ent of entries) {
        stack.push(join(p, ent.name));
      }
      continue;
    }

    if (st.isFile()) {
      try { chmodSync(p, 0o666); } catch { /* best-effort */ }
    }
  }
}

/**
 * Write docker-compose.yml file.
 */
export function writeDockerCompose(
  paths: DockerPaths,
  dockerConfigPath: string,
  envLines: string[],
  gatewayPort: string,
  defaultImage: string,
): void {
  const composePath = join(paths.outputDir, "docker-compose.yml");
  writeFileSync(
    composePath,
    buildDockerComposeYaml(dockerConfigPath, envLines, gatewayPort, defaultImage),
  );
  success(`Saved docker-compose.yml in ${composePath}`);
}

/**
 * Print Docker next steps instructions.
 */
export function printDockerNextSteps(
  paths: DockerPaths,
  gatewayPort: string,
  gatewayToken: string,
  tz: string,
  envLines: string[],
  defaultImage: string,
  useAnthropic: boolean,
  useOpenaiCodex: boolean,
  secrets: SecretsConfig,
): void {
  const C = COLORS;

  // Strip ANSI escape codes to get visible character count
  const stripAnsi = (s: string) => s.replace(/\x1b\[[0-9;]*m/g, "");
  // Visible width: emoji generally occupy 2 columns in terminals
  const visWidth = (s: string) => {
    const plain = stripAnsi(s);
    let w = 0;
    for (const ch of plain) {
      // Emoji and wide CJK chars take 2 columns; basic check via code point
      const cp = ch.codePointAt(0)!;
      w += cp > 0x1f600 || (cp >= 0x2600 && cp <= 0x27bf) || (cp >= 0x1f300 && cp <= 0x1faff) ? 2 : 1;
    }
    return w;
  };

  const composePath = join(paths.outputDir, "docker-compose.yml");
  const tokenShort = gatewayToken.slice(0, 8) + "...";

  // Build content lines first, then compute box width
  const rows: string[] = [
    "üìÅ Config     ~/.owliabot/app.yaml",
    "üîê Secrets    ~/.owliabot/secrets.yaml",
    "üîë Auth       ~/.owliabot/auth/",
    "üìÇ Workspace  ~/.owliabot/workspace/",
    `üê≥ Compose    ${composePath}`,
    "",
    `${C.CYAN}üåê Gateway${C.NC}`,
    `   URL:   ${C.GREEN}http://localhost:${gatewayPort}${C.NC}`,
    `   Token: ${C.YELLOW}${tokenShort}${C.NC}`,
  ];
  const titleRow = `${C.GREEN}‚úÖ  Setup Complete${C.NC}`;

  // Box inner width = max visible width of any row + 4 (2 padding each side)
  const maxVis = Math.max(visWidth(titleRow), ...rows.map(visWidth));
  const W = maxVis + 4;

  const border = (ch: string) => `${C.CYAN}${ch}${C.NC}`;
  const line = (content: string) => {
    const pad = W - visWidth(content) - 2;
    return `${border("‚îÇ")}  ${content}${" ".repeat(Math.max(0, pad))}${border("‚îÇ")}`;
  };
  const top   = `${C.CYAN}‚îå${"‚îÄ".repeat(W)}‚îê${C.NC}`;
  const mid   = `${C.CYAN}‚îú${"‚îÄ".repeat(W)}‚î§${C.NC}`;
  const bot   = `${C.CYAN}‚îî${"‚îÄ".repeat(W)}‚îò${C.NC}`;
  const empty = line("");

  console.log("");
  console.log(top);
  console.log(line(titleRow));
  console.log(mid);
  console.log(empty);
  for (const row of rows) {
    console.log(row === "" ? empty : line(row));
  }
  console.log(empty);
  console.log(bot);
  console.log("");
}
